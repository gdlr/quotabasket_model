---
title: ""
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

# Packages
library(tidyverse)
library(Matrix)
library(kableExtra)
library(lpSolve)
library(lpSolveAPI)
```



<center><h1>Multi-Species Fishery Model</h1></center>

<center><p>This is a multi-species fishery model that allows us to reflect how quota baskets affect stock levels</p></center>

<br>

### Our Model: Population Growth & Profit 
<br>

1. **Stock Dynamic**: biomass of species $j$ at time $t$

<center><p><mark>$X_{j,t+1} = X_{j,t} + rX_{j,t}\times (1-{X_{j,t}\over K_j}) - H_{j,t}$</mark></p></center>

2. **Harvest**: Harvest of species $j$ at time $t$ ; Harvest of technology $i$ at time $t$
(Kat translation: the first one: how much fish of species j is caught using all different techs, and the second one: how much of all fish species is caught using tech i)

$$
\begin{cases}
H_{j,t} = \sum_{i=1}^{techNum} q_{i,j}E_iX_{j,t}\\[2ex]
H_{i,t} = \sum_{j=1}^{speciesNum} q_{i,j}E_iX_{j,t}
\end{cases}
$$

3. **Profit**: Profit of technology $i$ at time $t$
<center><p><mark>$\pi_{i,t} = \sum_{j=1}^{speciesNum} p_j \times H_{i,j,t} - c_iE_i$</mark></p></center>

4. **Present Value of Net Benefit (PVNB)**: sum of the present value of profits of all technologies for the whole study period

<center><p><mark>$PVNB=\sum_{t=1}^{year}\sum_{i=1}^{techNum} [({1\over 1+\delta})^t \times \pi_{i,t}]$</mark></p></center>
*where,*<br>

- *$X_0$ = initial population size*<br>

- *$r$ = intrinsic growth rate*<br>

- *$K$ = carrying capacity*<br>

- *$q$ = catchability coefficient*<br>

- *$E$ = fishing effort*<br>

- *$p$ = price of 1 unit of fish*<br>

- *$\pi$ = revenue* <br>

- *$c$ = cost*<br>

- *$\delta$ = discount rate*<br>

<br>

### Check Our Model for Single Species

```{r, echo=FALSE}
stock_size_fx <- function(r = 0.1, K = 1, X0 = 0.1, years = 100, q = 0.01, E = 1, p = 1){
 
  ## Stock size ##
  # Create a stock size vector
  stock <- vector(length = years)
  stock[1] <- X0
  # And write a stock size equation
  for(y in 2:years){
    stock[y] = stock[y-1] + (r*stock[y-1])*(1-(stock[y-1]/K)) - q*E*stock[y-1]
  }
  
  ## Harvest ##
  # Create harvest vector:
  harvest <- vector(length = years)
  stock[1] <- 0
  # And write an equation...
  for(y in 2:years){
    harvest[y] = q*E*stock[y]
  }
  ## Profit
  # Create profit vector
  revenue <- vector(length = y)
  revenue[1] = 0
  # Write an equation...
  for(y in 2:years){
    revenue[y] = p*stock[y]
  }
  
  data.frame(year = seq(1, years, by = 1), 
             stock = stock, 
             harvest = harvest, 
             revenue = revenue)
}

test <- stock_size_fx(0.1, 1, 0.1, 100, 0.01, 1, 1)
plot(test)
```

**Great, this works for a single species. Can we include this for multiple species? **

1. We will need to define parameters for each of these species.

2. Then, we can write a function that allows us to plug these parameters in as a list of values, as many times as we want.

```{r, echo=FALSE}
# We first need to define species parameters 
params1 = list(0.1, 1, 0.1, 100, 0.01, 1, 1)
params2 = list(0.1, 5, 0.1, 100, 0.01, 1, 1)


multi_speciesfx <- function(...){
  # Define input arguments as a list to use with lapply later
  x = list(...)

  dcfx <- function(y){
    # This applies a function over a vector of parameters...
    # Unlist the params so we can plug them into our fx
    unlist(y)
    # do.call runs the function for certain parameters
    do.call(stock_size_fx, y)
  }
    # Apply it to every set of parameters
    lapply(x, dcfx)
  }

ms_test <- multi_speciesfx(params1, params2)

```

<br>

### Maxmize Profit for a multi-species and multi-technoligy model 

```{r}
# To maxmize profit, we need to create a catchability coefficient matrix first. 

# First, set seed to ensure we have the same result 
set.seed(666)


# set the number of species and technologies we want to study
species_num <- 4
tech_num <- 10


# set the number of years we want to model the stock dynamic 
year = 50


# set values for variables in the "Our Model" section
X0 = runif(species_num, max = 1, min = 0.1)

r = runif(species_num, max = 0.8, min = 0.1)

K = runif(species_num, max = 5, min = 1)

p = runif(species_num, max = 600, min = 50)

q = runif(species_num*tech_num, max = 0.01, min = 0)

c = runif(tech_num, min = 0.2, max = 8)

E = runif(tech_num, min = 0.1, max = 6)

o = 0.05  # o: discount rate
```

1. Imagine the *Species-Technology Catchability Coefficient Matrix*, and the cost and effort for each technology are given. Here, we create a model for `r species_num` species and `r tech_num` technologies.

```{r}
# randomly generate q (catchability coefficient) to the matrix
species_tech_matrix <- data.frame(matrix(q, nrow = tech_num, ncol = species_num))

# assign column and row names to the matrix
matrix_col_name <-  paste("species_", 1:species_num, sep = "")
colnames(species_tech_matrix) <- matrix_col_name

matrix_row_name <-  paste("tech_", 1:tech_num, sep = "")
rownames(species_tech_matrix) <- matrix_row_name

```

```{r}
# Addin cost and effort for each technology. 
species_tech_matrix$cost <- c

species_tech_matrix$effort <- E
```

```{r}
# print the catchability table in a nice formet 
matrix_table = kbl(species_tech_matrix, caption = "Catchability Coefficient Matrix") %>% 
  kable_classic(full_width = F, html_font = "Cambria")
matrix_table
```

<br>

2. Simulate the stock sizes for each of the `r species_num` species and `r tech_num` technologies over a period of `r year` years. Here are the first and last 5 lines of the simulated result. 

```{r}
# write a function to calculate the stock dynamic
stock_dynamic <- function(species_index, 
                          year, 
                          r, 
                          K, 
                          X0){
  
  stock= NULL
  stock=append(stock, X0)
  
  for( i in 2:year){
    
  # apply the first equation in the "Our Model" section
  X = stock[i-1]+r*stock[i-1]*(1-stock[i-1]/K) - sum(species_tech_matrix[species_index]*species_tech_matrix$effort)*stock[i-1] 
  
  stock=append(stock, X)
  
  }
  return(stock)
}
```

```{r}
# use the function above to simulate the stock dynamics for the 4 species
simulated_stock_dynamic = NULL

for(i in 1:species_num){
  stock = stock_dynamic(species_index = i, 
                        year = year, 
                        r = r[i], 
                        K = K[i], 
                        X0 = X0[i])
  
  simulated_stock_dynamic = cbind(simulated_stock_dynamic, stock)
  
}

```

```{r}
# turn the simulated result into a dataframe
simulated_stock_dynamic <- data.frame(simulated_stock_dynamic)

# create the column names and row names for the simulated result
stock_col_name <-  paste("stock_", 1:length(r), sep = "")
stock_row_name <-  paste("year_", 1:year, sep = "")

colnames(simulated_stock_dynamic) <- stock_col_name
rownames(simulated_stock_dynamic) <- stock_row_name
```

```{r}
# print the first and last 5 lines of the stock dynamic dataframe in a nice formet 
stock_table = kbl(simulated_stock_dynamic[c(1:5, (year-4):year),], caption = "Stock Dynamic") %>% 
  kable_classic(full_width = F, html_font = "Cambria")
stock_table
```

<br>

3. Simulate the harvest <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1 Simulate the harvest for each species
```{r}
#calculate the harvest for the each of the species
harvest_species = NULL

for(i in 1:species_num){
  # apply the 2.1 equation in the "Our Model" section
  X = sum(species_tech_matrix[i]*species_tech_matrix$effort)*simulated_stock_dynamic[i]

  harvest_species=c(harvest_species, X)

}

harvest_species = data.frame(harvest_species)
```

```{r}
# print the first and last 5 lines of the harvest_species dataframe in a nice formet 
harvest_species_table = kbl(harvest_species[c(1:5, (year-4):year),], caption = "Harvest for each species") %>% 
  kable_classic(full_width = F, html_font = "Cambria")

harvest_species_table
```
<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2 Simulate the harvest for each technology
```{r}
# write a function to calculate the harvest of one technology
one_tech_harvest <- function(tech_index){
  h_spe_tech = NULL
  # calculate the harvest for 1 species from 1 tech over time period, then sum the harvest for all species of 1 tech
  for(i in 1:species_num){
    x = species_tech_matrix[tech_index,i]*species_tech_matrix$effort[tech_index]*simulated_stock_dynamic[i]
    h_spe_tech = c(h_spe_tech, x)
  }
  
  return(rowSums(data.frame(h_spe_tech)))
}
```

```{r}
# calculate the harvest of all technology
harvest_tech <- NULL

for(i in 1:tech_num){
  harvest_tech <- cbind(harvest_tech, one_tech_harvest(i))
}


harvest_tech <- data.frame(harvest_tech)

# assign column and row names 
harvest_tech_col_name <-  paste("tech_", 1:tech_num, sep = "")
harvest_tech_row_name <-  paste("year_", 1:year, sep = "")

colnames(harvest_tech) <- harvest_tech_col_name
rownames(harvest_tech) <- harvest_tech_row_name
```

```{r}
# print the first and last 5 lines of the harvest_tech dataframe in a nice formet 
harvest_tech_table = kbl(harvest_tech[c(1:5, (year-4):year),c(1:3, (tech_num-2):tech_num)], caption = "Harvest for each technology") %>% 
  kable_classic(full_width = F, html_font = "Cambria")

harvest_tech_table
```

<br>


4. Simulate the profit generated by each technology and calculate the PVNB
```{r}
# calculate the cost for each technology 
cost_tech <- species_tech_matrix$cost*species_tech_matrix$effort
```


```{r}
# write a function to calculate the profit for one technology
profit_tech <- function(tech_index){
  
  # apply the third equation in "Our Model" section. Calculate the revenue generated by the 1st species of the chosen technology
  profit_tech_species = species_tech_matrix[tech_index, 1]*species_tech_matrix$effort[tech_index]*simulated_stock_dynamic[1]*p[1]
  
  # use a for-loop to generate the revenue for the rest of the species
  for(j in 2:species_num){
    x = species_tech_matrix[tech_index, j]*species_tech_matrix$effort[tech_index]*simulated_stock_dynamic[j]*p[j]
    profit_tech_species <- cbind(profit_tech_species,x)
  }

  # sum by rows to get the revenue generated by that technology across species. Subtract cost from revenue to get profit of that technology
  profit_tech = rowSums(profit_tech_species) - cost_tech[tech_index]
  
  return(profit_tech)
}

```


```{r}
# apply the function above to calculate the profit for all the technologies
profit = NULL

for(i in 1:tech_num){
  profit = cbind(profit, profit_tech(i))
}


# create the column names and row names for the profit dataframe
profit_col_name <-  paste("tech_", 1:tech_num, sep = "")
profit_row_name <-  paste("year_", 1:year, sep = "")

colnames(profit) <- profit_col_name
rownames(profit) <- profit_row_name

profit <- data.frame(profit)
```

```{r}
# add a column of total profit for each year 
total_profit <- rowSums(profit)
profit$total_profit <- total_profit

# calculate the present value of the profit generated by each technology each year
pv = NULL

for(i in 1:year){
  x = (1/(1+o))^(i-1)*profit$total_profit[i]
  pv = append(pv, x)
}

profit$present_value <- pv
```

```{r}
# print the first and last 5 lines of the profit dataframe in a nice formet 
profit_table = kbl(profit[c(1:5, (year-4):year), c(1:3, (tech_num-2):ncol(profit))], caption = "Profit for each technology") %>% 
  kable_classic(full_width = F, html_font = "Cambria")

profit_table
```

```{r}
# sum up the present values to get the PVNB
pvnb <- sum(profit$present_value)
```


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**The calculated PVNB is `r pvnb`.**

<br>


5. Use linear programming to maxmize PVNB by changing fishing effort
```{r, include=FALSE}
# use linear programming 

# set the number of decision variables 
lp_model <- make.lp(0, tech_num)

#set the objective function to maximization
lp.control(lp_model, sense="max")
```


```{r, include=FALSE}
lp_model
```

<br>
<br>
<br>
*Assumptions:*<br>
*1. We are interested in `r species_num` species and `r tech_num` technologies in a period of `r year` years*<br>
*2. $X_0$, $r$, $K$, $q$, $E$, $p$, $c$ are randomly generated*<br>
*3. $X_0$ is uniformly distributed with min = 0.1, and max = 1*<br>
*4. $r$ is uniformly distributed with min = 0.1, and max = 0.8*<br>
*5. $K$ is uniformly distributed with min = 1, and max = 5*<br>
*6. $q$ is uniformly distributed with min = 0, and max = 0.01*<br>
*7. $c$ is uniformly distributed with min = 0.2, and max = 8*<br>
*8. $E$ is uniformly distributed with min = 0.1, and max = 6*<br>
*9. $p$ is uniformly distributed with min = 50, and max = 600*<br>
*9. $\delta$ is `r o`*<br>
*11. $r$,$K$,$q$,$E$,$p$,$c$,$\delta$ do not change with respect to time*<br>
